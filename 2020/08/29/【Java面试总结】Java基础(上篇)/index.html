<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Java面试总结】Java基础(上篇) | silentcow</title><meta name="description" content="【Java面试总结】Java基础(上篇)"><meta name="keywords" content="Java面试总结,Java基础"><meta name="author" content="silentcow"><meta name="copyright" content="silentcow"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://silentcow.cn/2020/08/29/%E3%80%90Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E3%80%91Java%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="【Java面试总结】Java基础(上篇)"><meta property="og:url" content="http://silentcow.cn/2020/08/29/%E3%80%90Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E3%80%91Java%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)/"><meta property="og:site_name" content="silentcow"><meta property="og:description" content="【Java面试总结】Java基础(上篇)"><meta property="og:image" content="https://img.silentcow.cn/20200829160851.jpg"><meta property="article:published_time" content="2020-08-29T07:58:59.000Z"><meta property="article:modified_time" content="2020-08-29T08:09:14.892Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-29 16:09:14'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1. 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2. Java语言的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E4%BA%8E-JVM-JDK-%E5%92%8CJRE"><span class="toc-text">3. 关于 JVM JDK 和JRE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E5%92%8C-JRE"><span class="toc-text">JDK 和 JRE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Oracle-JDK-%E5%92%8C-OpenJDK-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">4. Oracle JDK 和 OpenJDK 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5. Java 和 C ++ 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%EF%BC%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">6. 什么是 Java 程序的主类？应用程序和小程序的主类有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-text">7. Java应用程序和小程序之间有哪些差别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8. 字符型常量和字符串常量的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9E%84%E9%80%A0%E5%99%A8Constructor-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB-override%EF%BC%9F"><span class="toc-text">9. 构造器Constructor 是否可以被 override？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10. 重载和重写的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">11. Java面向对象编程三大特性：封装、继承、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%9A"><span class="toc-text">封装：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-text">继承：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-text">多态：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-String-StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-text">12. String, StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-text">13. 自动拆箱和装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84%EF%BC%9F"><span class="toc-text">14. 在一个静态方法内调用一个非静态成员为什么是非法的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">15. 在 Java 中定义一个不做事且没有任何参数的构造方法的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-import-java-%E5%92%8C-javax-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">16. import java 和 javax 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17. 接口和抽象类的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">18. 成员变量与局部变量的区别有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">19. 创建一个对象用什么运算符？对象实体和对象引用有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">20. 什么是方法的返回值？返回值在类的方法里的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">22. 构造方法有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">23. 静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E4%B8%8E%E6%8C%87%E5%90%91%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%EF%BC%8C%E4%B8%A4%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">24. 对象的相等与指向它们的引用相等，两者有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%9C%A8%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B6%E7%9B%AE%E7%9A%84%E6%98%AF%EF%BC%9F"><span class="toc-text">25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://img.silentcow.cn/20200829160851.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">silentcow</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【Java面试总结】Java基础(上篇)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-29T07:58:59.000Z" title="发表于 2020-08-29 15:58:59">2020-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-29T08:09:14.892Z" title="更新于 2020-08-29 16:09:14">2020-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><ul>
<li><strong>面向过程：其性能高于面向对象</strong>。因为类调用时需要实例化，开销比较大，比较消耗资源，因此在考虑性能的条件下，比如linux、单片机等都采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象：面向对象易维护、易复用、易扩展</strong>。因为其有继承、多态、封装的特性，因此可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低。</strong></li>
</ul>
<h2 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="2. Java语言的特点"></a>2. Java语言的特点</h2><ol>
<li>简单易学；</li>
<li>面向对象（封装、继承、多态）；</li>
<li>平台无关性（Java虚拟机可以实现跨平台）；</li>
<li>可靠性；</li>
<li>安全性</li>
<li>支持多线程（C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 却提供了多线程支持）；</li>
<li>支持网络编程（Java 语言的诞生就是为了简化网络编程设计的，因此Java 不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存。</li>
</ol>
<blockquote>
<p>注：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用stdÇÉthread和stdÇÉasync来创建线程。参考链接：<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h2 id="3-关于-JVM-JDK-和JRE"><a href="#3-关于-JVM-JDK-和JRE" class="headerlink" title="3. 关于 JVM JDK 和JRE"></a>3. 关于 JVM JDK 和JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM 有针对不同系统的特定实现（windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码？采用字节码的好处是什么？</strong></p>
<ul>
<li><p>在Java中，代码就是字节码（扩展名是 .class的文件），它不面向任何的特定的处理器，只面向虚拟机。</p>
</li>
<li><p>Java语言通过通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释性语言可移植的特点。所以Java程序运行时比较高效。而且，由于字节码并不是针对特定的机器，因此，Java 程序无需重新编译便可在不同的操作系统的计算机运行。</p>
</li>
</ul>
<p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200829155705.png" alt="image-20200829081621291"></p>
<p><strong>需要格外注意的是： .class -&gt; 机器码 这一步。在这一步，JVM 类加载器首先会加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢；而且，有些方法和代码块是经常需要被重复调用的（也就是所谓的热点代码），所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。我们知道，机器码的运行效率是肯高于 Java 解释器的。这也解释了我们为什么会说 Java 是 编译与解释共存的语言。</strong></p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java虚拟机（JVM）是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java语言 “一次编译，随处可以运行”的关键所在。</p>
<hr>
<h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK 是 Java Development Kit，它是功能齐全的Java SDK。它拥有 JRE 所拥有的的一切，还有编译器（javac）和 工具（javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java 命令和 其它的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h2 id="4-Oracle-JDK-和-OpenJDK-的对比"><a href="#4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="4. Oracle JDK 和 OpenJDK 的对比"></a>4. Oracle JDK 和 OpenJDK 的对比</h2><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东⻄，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每6个月发一次主要版本，而OpenJDK 版本大概每三个月发布一次。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的。</li>
<li>Oracle JDK 比 OpenJDK更稳定。两者代码几乎相同，但是Oracle有更多的类额一些错误修复。</li>
<li>在 响应性 和 JVM 性能方面，Oracle JDK 与 OpenJDK相比提供了更好的性能；</li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK是根据二进制代码许可协议获得许可，而 OpenJDK 根据GPL v2 许可获得许可。</li>
</ol>
<h2 id="5-Java-和-C-的区别"><a href="#5-Java-和-C-的区别" class="headerlink" title="5. Java 和 C ++ 的区别"></a>5. Java 和 C ++ 的区别</h2><ul>
<li>都是面向对象的语言，都支持 封装、继承、多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C ++ 支持多重继承；虽然Java 的类不可以多继承，但是接口可以多继承</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li>在 C 语言中，字符串或字符数组最后都会有一个额外额字符“\0”来表示结束，但是，Java中没有结束符这一概念。 （具体参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sszgg2006/article/details/49148189%EF%BC%89">https://blog.csdn.net/sszgg2006/article/details/49148189）</a></li>
</ul>
<h2 id="6-什么是-Java-程序的主类？应用程序和小程序的主类有什么不同？"><a href="#6-什么是-Java-程序的主类？应用程序和小程序的主类有什么不同？" class="headerlink" title="6. 什么是 Java 程序的主类？应用程序和小程序的主类有什么不同？"></a>6. 什么是 Java 程序的主类？应用程序和小程序的主类有什么不同？</h2><p>一个程序中可以有多个类，但只有一个类是主类。在Java应用程序中，这个主类的类是包含在main() 方法的类中。而在Java小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h2 id="7-Java应用程序和小程序之间有哪些差别？"><a href="#7-Java应用程序和小程序之间有哪些差别？" class="headerlink" title="7. Java应用程序和小程序之间有哪些差别？"></a>7. Java应用程序和小程序之间有哪些差别？</h2><p>简单来说应用程序是从主线程启动（也就是main（）方法）。applet小程序没有main（）方法，主要是嵌在浏览器页面上运行（调用init（）或者run（）来启动），嵌入浏览器这点跟flash的小游戏类似。</p>
<h2 id="8-字符型常量和字符串常量的区别？"><a href="#8-字符型常量和字符串常量的区别？" class="headerlink" title="8. 字符型常量和字符串常量的区别？"></a>8. 字符型常量和字符串常量的区别？</h2><ol>
<li>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符</li>
<li>含义上：字符常量相当于一个整型值（ASCII 值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放的位置）</li>
<li>占内存大小：字符常量只占2个字节；字符串常量占若干个字节（注意：char在Java中占两个字节）</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200829155706.png" alt="image-20200829094333888"></p>
<h2 id="9-构造器Constructor-是否可以被-override？"><a href="#9-构造器Constructor-是否可以被-override？" class="headerlink" title="9. 构造器Constructor 是否可以被 override？"></a>9. 构造器Constructor 是否可以被 override？</h2><p>Constructor 不能被 Override（重写），但是可以overload（重载），所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h2><ul>
<li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</li>
<li>重写就是当子类继承父类的相同方法，输入数据一样，但是要做出有别于父类的响应时，就要覆盖父类方法</li>
</ul>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，也可以抛出不同的异常。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200829155707.png" alt="image-20200829095146697"></p>
<p><strong>综上所述：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写</p>
<ol>
<li>参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载</li>
<li>返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载</li>
<li>访问修饰符的限制一定要大于等于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li>
<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>
<li>如果父类方法访问修饰符为 private/final/static，则子类就不能重写该方法，但是被static修饰的方法能够被再次声明</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>综上：重写就是子类对父类的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的异常或更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="11-Java面向对象编程三大特性：封装、继承、多态"><a href="#11-Java面向对象编程三大特性：封装、继承、多态" class="headerlink" title="11. Java面向对象编程三大特性：封装、继承、多态"></a>11. Java面向对象编程三大特性：封装、继承、多态</h2><h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，我们能够很方便的复用以前的代码。</p>
<p><strong>注意：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法(包括私有属性和私有方法)，但是父类的私有属性和方法，子类是无法访问，只是拥有；</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；</li>
<li>子类可以用自己的方法实现父类的方法。</li>
</ol>
<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>多态就是同一个行为具有多个不同表现形式或形态的能力；</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/dt-java.png" alt="img"></p>
<p><strong>多态的优点：</strong></p>
<ol>
<li>消除类型之间的耦合关系；</li>
<li>可替换性；</li>
<li>可扩充性；</li>
<li>接口性；</li>
<li>灵活性；</li>
<li>简化性；</li>
</ol>
<p><strong>多态存在的三个必要条件：</strong></p>
<ol>
<li>继承；</li>
<li>重写；</li>
<li>父类引用指向子类对象</li>
</ol>
<p><strong>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中的同一方法）。</strong></p>
<h2 id="12-String-StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"><a href="#12-String-StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="12. String, StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"></a>12. String, StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？</h2><p><strong>可变性：</strong></p>
<p>简单的来说：String 类 中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>,所以String对象是不可变的。</p>
<blockquote>
<p>注：Java 9 之后，String类的实现改用 byte 数组存储字符串</p>
<p><code>private final byte value[]</code></p>
</blockquote>
<p>而 StringBuffer 和 StringBuilder 都继承自 AbstractStringBuilder 类，在AbstactStringBuilder 中也是使用字符数组保存字符串<code>char value[]</code>,但是没有用 final 关键字修饰，所以这两种对象是可变的。</p>
<p><strong>线程安全性：</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p>AbstactStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以线程时安全的。StringBuilder 并没有对方法进行加同步锁，所以是 非线程安全的。</p>
<p><strong>性能：</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String对象。StringBuffer 每次都会对 StringBuffer 本身进行操作，而不是生成新的对象并改变对象引用。相同条件下，使用 StringBuilder 相比 使用 StringBuffer 仅能获得10% ~ 15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据：适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据：适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据：适用 StringBuffer</li>
</ol>
<hr>
<h2 id="13-自动拆箱和装箱"><a href="#13-自动拆箱和装箱" class="headerlink" title="13. 自动拆箱和装箱"></a>13. 自动拆箱和装箱</h2><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型</li>
</ul>
<p>基本数据类型对应的包装器类型：</p>
<table>
<thead>
<tr>
<th>int (4字节)</th>
<th>Integer</th>
</tr>
</thead>
<tbody><tr>
<td>byte (1字节)</td>
<td>Byte</td>
</tr>
<tr>
<td>short （2字节）</td>
<td>Short</td>
</tr>
<tr>
<td>long（8字节）</td>
<td>Long</td>
</tr>
<tr>
<td>float（4字节）</td>
<td>Float</td>
</tr>
<tr>
<td>double（8字节）</td>
<td>Double</td>
</tr>
<tr>
<td>char （2字节）</td>
<td>Character</td>
</tr>
<tr>
<td>boolean（未定）</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p><strong>装箱和拆箱是如何实现的</strong>？</p>
<p>在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。其他的也类似，比如Double、Character</p>
<p>因此可以用一句话总结<strong>装箱和拆箱的实现过程</strong>：</p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
<p>关于装箱和拆箱的更多内容以及面试必记，请访问：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入解剖Java中的装箱和拆箱</a></p>
<hr>
<h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的？"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>由于静态方法可以不通过对象调用，因此在静态方法里面，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h2 id="15-在-Java-中定义一个不做事且没有任何参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有任何参数的构造方法的作用" class="headerlink" title="15. 在 Java 中定义一个不做事且没有任何参数的构造方法的作用"></a>15. 在 Java 中定义一个不做事且没有任何参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用<code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用<code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。</p>
<p>解决方法是：在父类中加上一个不做事且没有任何参数的构造方法。</p>
<h2 id="16-import-java-和-javax-有什么区别？"><a href="#16-import-java-和-javax-有什么区别？" class="headerlink" title="16. import java 和 javax 有什么区别？"></a>16. import java 和 javax 有什么区别？</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h2 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17. 接口和抽象类的区别是什么？"></a>17. 接口和抽象类的区别是什么？</h2><ol>
<li>接口的方法默认是 public，所有方法在接口不能有实现（Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法</li>
<li>接口中除了 static,final 变量，不能有其他变量，而抽象类中则不一定</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends 关键字扩展多个接口</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<blockquote>
<p>注：</p>
<ol>
<li>在 JDK 8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</li>
<li>jdk 9 的接口被允许定义私有方法。</li>
</ol>
</blockquote>
<p>总结一下 jdk7 ~ jdk 9，Java中接口概念的变化：</p>
<ol>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h2 id="18-成员变量与局部变量的区别有哪些？"><a href="#18-成员变量与局部变量的区别有哪些？" class="headerlink" title="18. 成员变量与局部变量的区别有哪些？"></a>18. 成员变量与局部变量的区别有哪些？</h2><ol>
<li><p><strong>定义的位置不一样</strong></p>
<p> 局部变量：写在方法内部</p>
<p> 成员变量：写在方法外部，直接写在类当中</p>
</li>
<li><p><strong>作用范围不一样</strong></p>
<p> 局部变量：只有方法当中才可以使用，出了方法就不能再用</p>
<p> 成员变量：整个类全都可以通用。</p>
</li>
<li><p><strong>默认值不一样</strong></p>
<p> 局部变量：没有默认值，如果想要使用，必须手动进行赋值</p>
<p> 成员变量：如果没有赋值，会有默认值，规则和数组一样</p>
</li>
<li><p><strong>内存的位置不一样</strong></p>
<p> 局部变量：位于栈内存</p>
<p> 成员变量，位于堆内存。</p>
</li>
<li><p><strong>生命周期不一样</strong></p>
<p> 局部变量：随着方法进栈而诞生，随着方法出栈而死亡。</p>
<p> 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失。</p>
</li>
</ol>
<h2 id="19-创建一个对象用什么运算符？对象实体和对象引用有何不同？"><a href="#19-创建一个对象用什么运算符？对象实体和对象引用有何不同？" class="headerlink" title="19. 创建一个对象用什么运算符？对象实体和对象引用有何不同？"></a>19. 创建一个对象用什么运算符？对象实体和对象引用有何不同？</h2><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="20-什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#20-什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="20. 什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>20. 什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><p>方法返回值：是指我们获取到的某个方法体中的代码执行后产生的结果（前提是该方法可能产生结果）；</p>
<p>返回值的作用：接收出结果，使得它可以用于其他的操作。</p>
<h2 id="21-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#21-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>21. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h2><p>主要作用是完成对类对象的初始化工作；</p>
<p>可以执行；</p>
<p>因为一个类即使没有声明构造方法，也会有默认的不带参数的构造方法。</p>
<h2 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h2><ol>
<li>名字和类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动处理，无需调用。</li>
</ol>
<h2 id="23-静态方法和实例方法有何不同？"><a href="#23-静态方法和实例方法有何不同？" class="headerlink" title="23. 静态方法和实例方法有何不同？"></a>23. 静态方法和实例方法有何不同？</h2><ol>
<li>在外部调用静态方法时，可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<h2 id="24-对象的相等与指向它们的引用相等，两者有什么不同？"><a href="#24-对象的相等与指向它们的引用相等，两者有什么不同？" class="headerlink" title="24. 对象的相等与指向它们的引用相等，两者有什么不同？"></a>24. 对象的相等与指向它们的引用相等，两者有什么不同？</h2><p>对象相等，比的是内存中存放的内容是否相等；</p>
<p>而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2><p>帮助子类做初始化工作。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">silentcow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://silentcow.cn/2020/08/29/%E3%80%90Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E3%80%91Java%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)/">http://silentcow.cn/2020/08/29/%E3%80%90Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E3%80%91Java%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://silentcow.cn" target="_blank">silentcow</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://img.silentcow.cn/20200829160851.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/30/%E5%89%91%E6%8C%87Offer%2055-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"><img class="prev-cover" data-lazy-src="https://img.silentcow.cn/20200830005616.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【剑指Offer】二叉树的深度</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/28/%E8%B0%88%E8%B0%88%E8%BF%99%E5%8D%8A%E4%B8%AA%E6%9C%88%E6%96%AD%E6%9B%B4%E4%BB%A5%E5%8F%8A%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E8%AE%A1%E5%88%92/"><img class="next-cover" data-lazy-src="https://img.silentcow.cn/20200828123009.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">谈谈这半个月断更以及接下来的计划</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/30/【Java面试】Java基础(下篇)/" title="【Java面试总结】Java基础(下篇)"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200829161806.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-30</div><div class="relatedPosts_title">【Java面试总结】Java基础(下篇)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/31/【Java面试总结】完整版（更新中）/" title="【Java面试总结】完整归类版"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200831104016.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-31</div><div class="relatedPosts_title">【Java面试总结】完整归类版</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/【Java面试】MySQL/" title="【Java面试总结】MySQL"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200911094928.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-11</div><div class="relatedPosts_title">【Java面试总结】MySQL</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/08/【Java面试】计算机网络/" title="【Java面试总结】计算机网络"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200908205424.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-08</div><div class="relatedPosts_title">【Java面试总结】计算机网络</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/06/【Java面试】多线程/" title="【Java面试总结】多线程"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200906214127.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-06</div><div class="relatedPosts_title">【Java面试总结】多线程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/02/【Java面试】Java集合/" title="【Java面试总结】Java集合"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200903001313.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="relatedPosts_title">【Java面试总结】Java集合</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://img.silentcow.cn/20200829160851.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By silentcow</div><div class="footer_custom_text">❤把生命浪费在美好的事物上❤</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>陕ICP备20007232</span></a></div><a src="https://www.upyun.com/static/img/%E6%A0%B7%E5%BC%8F%E5%9B%BE.7cf927c.png" style="width: 248px" target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral">本站由又拍云提供CDN加速服务</a></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '8o941pQWci2RW0uP8DjOWl2P-gzGzoHsz',
      appKey: 'WQPP2IUvnbXswLjEgsgSJy0T',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: '昵称(必填),邮箱(必填),主页'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('昵称(必填),邮箱(必填)') { valine.config.requiredFields= '昵称(必填),邮箱(必填)'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>