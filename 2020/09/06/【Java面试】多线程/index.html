<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Java面试总结】多线程 | silentcow</title><meta name="description" content="【Java面试总结】多线程"><meta name="keywords" content="Java面试总结,多线程"><meta name="author" content="silentcow"><meta name="copyright" content="silentcow"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://silentcow.cn/2020/09/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="【Java面试总结】多线程"><meta property="og:url" content="http://silentcow.cn/2020/09/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta property="og:site_name" content="silentcow"><meta property="og:description" content="【Java面试总结】多线程"><meta property="og:image" content="https://img.silentcow.cn/20200906214127.jpg"><meta property="article:published_time" content="2020-09-06T13:36:55.000Z"><meta property="article:modified_time" content="2020-09-06T13:44:56.641Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-06 21:44:56'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">43</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">1. 什么是线程和进程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="toc-text">进程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">线程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2. 请简要描述线程与进程的关系，区别以及优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">图解进程和线程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-text">程序计数器为什么是私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-text">虚拟机栈和本地方法栈为什么是私有的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">一句话简单了解堆和方法区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 说说并发和并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-text">4. 为什么要使用多线程呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">5. 使用多线程可能带来什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-text">6. 说说线程的生命周期和状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">7. 什么是上下文切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">8. 什么是线程死锁？如何避免死锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-text">认识线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">如何避免线程死锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B4%E8%AF%B4-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-text">9. 说说 sleep() 方法和 wait() 方法区别和共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">11. synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">1.说一说自己对于 synchronized 关键字的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97"><span class="toc-text">2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">3. synchronized 关键字最主要的三种使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%B2%E4%B8%80%E4%B8%8B-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">4. 讲一下 synchronized 关键字的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4-JDK1-6-%E4%B9%8B%E5%90%8E%E7%9A%84synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E4%BC%98%E5%8C%96%E5%90%97"><span class="toc-text">5. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B0%88%E8%B0%88-synchronized%E5%92%8CReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6. 谈谈 synchronized和ReentrantLock 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">12. volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-ThreadLocal"><span class="toc-text">13. ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">14. 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">1. 为什么要用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. 实现Runnable接口和Callable接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8Cexecute-%E6%96%B9%E6%B3%95%E5%92%8Csubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-text">3. 执行execute()方法和submit()方法的区别是什么呢？</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://img.silentcow.cn/20200906214127.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">silentcow</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【Java面试总结】多线程</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-06T13:36:55.000Z" title="发表于 2020-09-06 21:36:55">2020-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-06T13:44:56.641Z" title="更新于 2020-09-06 21:44:56">2020-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-什么是线程和进程？"><a href="#1-什么是线程和进程？" class="headerlink" title="1. 什么是线程和进程？"></a>1. 什么是线程和进程？</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个即是一个进程从创建、运行到消亡的过程。</p>
<p>在Java中，当我们启动 main 函数时，其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200906214433.png" alt="image-20200905093743470"></p>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>线程比进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器、虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小的多，也正因如此，线程也被称作轻量级进程。</p>
<p>Java 天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> multiThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> silentCow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/5 10:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，仅打印线程ID 和 线程名称信息</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span>+threadInfo.getThreadId() +<span class="string">&quot;] &quot;</span>+threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行main 方法即可）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6] Monitor Ctrl-Break</span><br><span class="line">[5] Attach Listener  &#x2F;&#x2F;添加事件</span><br><span class="line">[4] Signal Dispatcher     &#x2F;&#x2F; 分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer    &#x2F;&#x2F;调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler     &#x2F;&#x2F;清除 reference 线程</span><br><span class="line">[1] main    &#x2F;&#x2F;main 线程,程序入口</span><br></pre></td></tr></table></figure>

<p>综上可以看出<strong>：一个 <code>Java</code> 程序的运行是 <code>main</code> 线程和多个其他线程同时运行。</strong></p>
<h2 id="2-请简要描述线程与进程的关系，区别以及优缺点"><a href="#2-请简要描述线程与进程的关系，区别以及优缺点" class="headerlink" title="2. 请简要描述线程与进程的关系，区别以及优缺点"></a>2. 请简要描述线程与进程的关系，区别以及优缺点</h2><p>从 JVM 角度说进程和线程之间的关系</p>
<p>详细内容请阅读：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md">Java相关/可能是把Java内存区域讲的最清楚的一篇文章</a></p>
<h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200906214434.png" alt="image-20200905111614452"></p>
<p>从上图可以看出：一个进程可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>（JDK 1.8 之后的元空间）资源，但是每个线程有 自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正好相反。</p>
<blockquote>
<p>扩展内容：</p>
<p>思考：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
</blockquote>
<h3 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h3><p>程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够 知道该线程上次运行到哪了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了：<strong>线程切换后能够恢复到正确的执行位置</strong>。</p>
<h3 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h3><ul>
<li><strong>虚拟机栈</strong>：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈</strong>：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为了虚拟机栈使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，<strong>为了保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区都是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="3-说说并发和并行的区别"><a href="#3-说说并发和并行的区别" class="headerlink" title="3. 说说并发和并行的区别"></a>3. 说说并发和并行的区别</h2><ul>
<li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并行</strong>：单位时间内，多个任务同时执行</li>
</ul>
<h2 id="4-为什么要使用多线程呢？"><a href="#4-为什么要使用多线程呢？" class="headerlink" title="4. 为什么要使用多线程呢？"></a>4. 为什么要使用多线程呢？</h2><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说</strong>：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到100%了。</li>
<li><strong>多核时代</strong>:多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h2 id="5-使用多线程可能带来什么问题？"><a href="#5-使用多线程可能带来什么问题？" class="headerlink" title="5. 使用多线程可能带来什么问题？"></a>5. 使用多线程可能带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<h2 id="6-说说线程的生命周期和状态"><a href="#6-说说线程的生命周期和状态" class="headerlink" title="6. 说说线程的生命周期和状态?"></a>6. 说说线程的生命周期和状态?</h2><p>点击跳转【Java面试】Java基础(下篇)/#30-线程有哪些基本状态？<a target="_blank" rel="noopener" href="https://www.silentcow.cn/2020/08/30/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91Java%E5%9F%BA%E7%A1%80(%E4%B8%8B%E7%AF%87)/#30-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9F">线程有哪些基本状态</a></p>
<h2 id="7-什么是上下文切换？"><a href="#7-什么是上下文切换？" class="headerlink" title="7. 什么是上下文切换？"></a>7. 什么是上下文切换？</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="8-什么是线程死锁？如何避免死锁？"><a href="#8-什么是线程死锁？如何避免死锁？" class="headerlink" title="8. 什么是线程死锁？如何避免死锁？"></a>8. 什么是线程死锁？如何避免死锁？</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是：多个线程同时被阻塞，它们中的一个或全部都在等待某个资源被释放。由于线程被无期限的阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200906214435.png" alt="image-20200906145736973"></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> deadLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> silentCow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/6 14:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">// 资源1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">// 资源2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1) </code>获得<code> resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000)</code>;让线程 A 休眠 <code>1s </code>为的是让线程 B 得到执行然后获取到 <code>resource2</code> 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<blockquote>
<p><strong>产生死锁必须具备的条件：</strong></p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用；</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕之后才能释放资源；</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
</blockquote>
<h3 id="如何避免线程死锁？"><a href="#如何避免线程死锁？" class="headerlink" title="如何避免线程死锁？"></a>如何避免线程死锁？</h3><p>上面说了产生死锁的必备条件，那么为了避免死锁，只需破坏其中的一个条件即可：</p>
<ol>
<li><strong>破坏互斥条件</strong>：这个条件我们没有办法破坏，因为我们的锁本来就是想让他们互斥的（临界资源需要互斥访问）；</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源；</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放资源占有的资源；</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p>线程 2 的代码修改成下面这样就不会产生死锁了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br></pre></td></tr></table></figure>

<p><strong>分析上面的代码为什么避免了死锁？</strong></p>
<p>线程 1 首先获得到<code> resource1</code> 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取<code>resource2</code> 的监视器锁，可以获取到。然后线程 1 释放了对<code> resource1</code>、<code>resource2</code> 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h2 id="9-说说-sleep-方法和-wait-方法区别和共同点"><a href="#9-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="9. 说说 sleep() 方法和 wait() 方法区别和共同点"></a>9. 说说 sleep() 方法和 wait() 方法区别和共同点</h2><ul>
<li>两者最主要的区别在于：<code>sleep</code> 方法没有释放锁，而 <code>wait</code> 方法释放了锁</li>
<li>两者都可以暂停线程的执行</li>
<li><code>wait</code> 通常被用于线程间交互/通信，<code>sleep</code> 通常被用于暂停执行</li>
<li><code>wait() </code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者<code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用<code> wait(long timeout)</code>超时后线程会自动苏醒</li>
</ul>
<h2 id="10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用run-方法？"><a href="#10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？"></a>10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？</h2><p><code>new</code> 一个 <code>Thread</code> ，线程进入了新建状态；调用 <code>start()</code> 方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以运行了。<code>start()</code> 会执行线程 的响应准备工作，然后自动执行<code>run()</code>方法的内容，这是真正的多线程工作。而直接执行 <code>run() </code>方法，会把<code>run()</code>方法当成一个 <code>main </code>线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法可启动线程并使线程进入就绪状态；而 run 方法只是 Thread 的一个普通方法，还是在主线程里执行。</strong></p>
<h2 id="11-synchronized-关键字"><a href="#11-synchronized-关键字" class="headerlink" title="11. synchronized 关键字"></a>11. synchronized 关键字</h2><h3 id="1-说一说自己对于-synchronized-关键字的了解"><a href="#1-说一说自己对于-synchronized-关键字的了解" class="headerlink" title="1.说一说自己对于 synchronized 关键字的了解"></a>1.说一说自己对于 synchronized 关键字的了解</h3><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较⻓的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h3 id="2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p>暂无，后期写</p>
<h3 id="3-synchronized-关键字最主要的三种使用方式"><a href="#3-synchronized-关键字最主要的三种使用方式" class="headerlink" title="3. synchronized 关键字最主要的三种使用方式"></a>3. synchronized 关键字最主要的三种使用方式</h3><ul>
<li><strong>修饰实例方法</strong>：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new 了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<p><strong>总结</strong>：<code>synchronized</code>关键字加到 <code>static </code>静态方法和<code> synchronized(class)</code>代码块上都是是给<code> Class</code>类上锁。<code>synchronized </code>关键字加到实例方法上是给对象实例上锁。尽量不要使用<code>synchronized(String a) </code>因为<code>JVM</code>中，字符串常量池具有缓存功能！</p>
<h3 id="4-讲一下-synchronized-关键字的底层原理"><a href="#4-讲一下-synchronized-关键字的底层原理" class="headerlink" title="4. 讲一下 synchronized 关键字的底层原理"></a>4. 讲一下 synchronized 关键字的底层原理</h3><p>暂 略</p>
<h3 id="5-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#5-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="5. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>5. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md">详细请点击阅读</a></p>
<h3 id="6-谈谈-synchronized和ReentrantLock-的区别"><a href="#6-谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="6. 谈谈 synchronized和ReentrantLock 的区别"></a>6. 谈谈 synchronized和ReentrantLock 的区别</h3><p>①、两者都是可重入锁</p>
<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p>②、synchronized 依赖于 JVM ，而 ReentrantLock 依赖于 API</p>
<p><code>synchronized </code>是依赖于<code> JVM</code> 实现的，前面我们也讲到了虚拟机团队在<code> JDK1.6</code> 为 <code>synchronized </code>关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是<code>JDK</code>层面实现的（也就是<code> API</code> 层面，需要<code>lock()</code>和<code>unlock()</code>方法配合<code>try/finally </code>语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p>③、ReentrantLock 比 synchronized 增加了一些高级功能</p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>
<ul>
<li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过<code>lock.lockInterruptibly()</code>来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong><code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> <code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待/通知机制，<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition() </code>方法。<code>Condition</code>是<code>JDK1.5</code>之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 <code>JVM </code>选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”，</strong>这个功能非常重要，而且是<code>Condition</code>接口默认提供的。而<code>synchronized</code>关键字就相当于整个<code>Lock</code>对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</li>
</ul>
<p>④、性能已不是选择标准</p>
<h2 id="12-volatile关键字"><a href="#12-volatile关键字" class="headerlink" title="12. volatile关键字"></a>12. volatile关键字</h2><p>暂略</p>
<h2 id="13-ThreadLocal"><a href="#13-ThreadLocal" class="headerlink" title="13. ThreadLocal"></a>13. ThreadLocal</h2><p>暂略</p>
<h2 id="14-线程池"><a href="#14-线程池" class="headerlink" title="14. 线程池"></a>14. 线程池</h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1. 为什么要用线程池？"></a>1. 为什么要用线程池？</h3><blockquote>
<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率</p>
</blockquote>
<p>线程池提供了一种限制和管理资源（包括执行一个任务）。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="2-实现Runnable接口和Callable接口的区别"><a href="#2-实现Runnable接口和Callable接口的区别" class="headerlink" title="2. 实现Runnable接口和Callable接口的区别"></a>2. 实现Runnable接口和Callable接口的区别</h3><p><code>Runnable</code>自<code>Java 1.0</code>以来一直存在，但<code>Callable</code>仅在<code>Java 1.5</code>中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<code>Runnable</code>接口不会返回结果或抛出检查异常，但是<code>Callable</code>接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用<code>Runnable</code>接口，这样代码看起来会更加简洁。</p>
<p>工具类``Executors<code>可以实现</code>Runnable<code>对象和</code>Callable<code>对象之间的相互转换。（</code>Executors.callable（Runnable task）<code>或</code>Executors.callable（Runnable task，Object resule）`）。</p>
<h3 id="3-执行execute-方法和submit-方法的区别是什么呢？"><a href="#3-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="3. 执行execute()方法和submit()方法的区别是什么呢？"></a>3. 执行execute()方法和submit()方法的区别是什么呢？</h3><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务</strong>，所以无法判断任务是否被线程池执行成功与否；</li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务</strong>。线程池会返回一个<code>Future</code>类型的对象，通过这个<code>Future</code>对象可以判断任务是否执行成功，并且可以通过<code>Future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用<code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">silentcow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://silentcow.cn/2020/09/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/">http://silentcow.cn/2020/09/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://silentcow.cn" target="_blank">silentcow</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://img.silentcow.cn/20200906214127.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" data-lazy-src="https://img.silentcow.cn/20200908205424.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Java面试总结】计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/04/%E5%89%91%E6%8C%87Offer%2017-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"><img class="next-cover" data-lazy-src="https://img.silentcow.cn/20200830005616.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【剑指Offer】打印从1到最大的n位数</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/31/【Java面试总结】完整版（更新中）/" title="【Java面试总结】完整归类版"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200831104016.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-31</div><div class="relatedPosts_title">【Java面试总结】完整归类版</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/15/【Java面试】常用框架之 Spring/" title="【Java面试总结】常用框架之Spring"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200915203105.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="relatedPosts_title">【Java面试总结】常用框架之Spring</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/【Java面试】Redis/" title="【Java面试总结】Redis"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200911172547.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-11</div><div class="relatedPosts_title">【Java面试总结】Redis</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/【Java面试】MySQL/" title="【Java面试总结】MySQL"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200911094928.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-11</div><div class="relatedPosts_title">【Java面试总结】MySQL</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/08/【Java面试】计算机网络/" title="【Java面试总结】计算机网络"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200908205424.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-08</div><div class="relatedPosts_title">【Java面试总结】计算机网络</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/02/【Java面试】Java集合/" title="【Java面试总结】Java集合"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200903001313.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="relatedPosts_title">【Java面试总结】Java集合</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://img.silentcow.cn/20200906214127.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By silentcow</div><div class="footer_custom_text">❤把生命浪费在美好的事物上❤</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>陕ICP备20007232</span></a></div><a src="https://www.upyun.com/static/img/%E6%A0%B7%E5%BC%8F%E5%9B%BE.7cf927c.png" style="width: 248px" target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral">本站由又拍云提供CDN加速服务</a></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '8o941pQWci2RW0uP8DjOWl2P-gzGzoHsz',
      appKey: 'WQPP2IUvnbXswLjEgsgSJy0T',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: '昵称(必填),邮箱(必填),主页'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('昵称(必填),邮箱(必填)') { valine.config.requiredFields= '昵称(必填),邮箱(必填)'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>