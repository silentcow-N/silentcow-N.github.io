<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Java面试总结】计算机网络 | silentcow</title><meta name="description" content="【Java面试总结】计算机网络"><meta name="keywords" content="Java面试总结,计算机网络"><meta name="author" content="silentcow"><meta name="copyright" content="silentcow"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://silentcow.cn/2020/09/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="【Java面试总结】计算机网络"><meta property="og:url" content="http://silentcow.cn/2020/09/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta property="og:site_name" content="silentcow"><meta property="og:description" content="【Java面试总结】计算机网络"><meta property="og:image" content="https://img.silentcow.cn/20200908205424.jpg"><meta property="article:published_time" content="2020-09-08T12:55:37.000Z"><meta property="article:modified_time" content="2020-09-08T12:55:56.851Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-08 20:55:56'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-OSI-%E4%B8%8E-TCP-IP%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">1. OSI 与 TCP&#x2F;IP各层的结构与功能，都有哪些协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9A"><span class="toc-text">应用层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%9A"><span class="toc-text">运输层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A"><span class="toc-text">网络层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%9A"><span class="toc-text">数据链路层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%9A"><span class="toc-text">物理层：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%92%8C-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-text">2. 三次握手 和 四次挥手（面试高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">为什么要三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN"><span class="toc-text">为什么要传回 SYN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E4%BA%86-SYN%EF%BC%8C%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ACK"><span class="toc-text">传了 SYN，为啥还要传 ACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-text">为什么要四次挥手？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TCP-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3. TCP,UDP 协议的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-text">4. TCP 协议如何证可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ARQ-%E5%8D%8F%E8%AE%AE"><span class="toc-text">5. ARQ 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-text">停止等待协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%ADARQ-%E5%8D%8F%E8%AE%AE"><span class="toc-text">连续ARQ 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">6. 滑动窗口和流量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">7. 拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-url-%E5%9C%B0%E5%9D%80-gt-gt-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-text">8. 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程（面试高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">9. 状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">10. 各种协议与HTTP协议之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">11. HTTP 长连接，短连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-text">12. HTTP是不保存状态的协议,如何保存用户状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Cookie%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8CSession%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">13. Cookie的作用是什么？和Session有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-URI-%E5%92%8C-URL-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14. URI 和 URL 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. HTTP 和 HTTPS 的区别？</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://img.silentcow.cn/20200908205424.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">silentcow</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/weiyu/"><i class="fa-fw fas fa-star"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 推荐网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【Java面试总结】计算机网络</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-08T12:55:37.000Z" title="发表于 2020-09-08 20:55:37">2020-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-08T12:55:56.851Z" title="更新于 2020-09-08 20:55:56">2020-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-OSI-与-TCP-IP各层的结构与功能，都有哪些协议？"><a href="#1-OSI-与-TCP-IP各层的结构与功能，都有哪些协议？" class="headerlink" title="1. OSI 与 TCP/IP各层的结构与功能，都有哪些协议？"></a>1. OSI 与 TCP/IP各层的结构与功能，都有哪些协议？</h2><p>我们在学习的时候，一般采用折中的办法，也就是中和 OSI 与 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简介又能将概念阐述清楚。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204848.png" alt="image-20200907151339505"></p>
<h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>其的任务是 <strong>通过应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持<strong>电子邮件的 SMTP协议</strong>等等，我们<strong>把应用层交互的数据单元称为报文</strong>。</p>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protoco）是互联网上应用最为广泛的一种网络协议。所有的万维网（WWW）文件都必须遵守这个协议。设计HTTP最初的目的是为了提供一种发布和接收 HTML 页面的方法</p>
</blockquote>
<h3 id="运输层："><a href="#运输层：" class="headerlink" title="运输层："></a>运输层：</h3><p>其主要任务就是<strong>负责两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于同一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要有以下两种协议：</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）：提供<strong>面向链接的、可靠</strong>的数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）：：提供<strong>无连接的</strong>。尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）</li>
</ol>
<p>TCP 与 UDP 对比 见下面问题三。</p>
<h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><p>在 <strong>计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是 选择合适的网间路由和交换节点</strong>，<strong>确保数据及时传送</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP协议</strong>，因此分组也叫<strong>IP数据报</strong>，也叫 <strong>数据报</strong>。</p>
<blockquote>
<p>注意：不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混。另外，无论哪层的数据单元，都可笼统的用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
</blockquote>
<p>互联网是由大量的异构（heterogeneous）网络通过路由（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h3 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专⻔的链路层的协议</strong>。在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p>在物理层上所传送的数据单位是比特。<strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong>使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不⻅的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>图片来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200907200023.gif" alt="0_1325744597WM32"></p>
<h2 id="2-三次握手-和-四次挥手（面试高频）"><a href="#2-三次握手-和-四次挥手（面试高频）" class="headerlink" title="2. 三次握手 和 四次挥手（面试高频）"></a>2. 三次握手 和 四次挥手（面试高频）</h2><p>目的：为了准确无误地把数据送达到目标处，TCP协议采用了三次握手策略</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204849.png" alt="image-20200907201309984"></p>
<p>如图，两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)</p>
<p>简图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204850.png" alt="image-20200907201932842"></p>
<ul>
<li>客户端 — 发送带有 SUN 标志的数据包 — 一次握手 - 服务端</li>
<li>服务端 — 发送带有 SYN/ACK 标志的数据包 — 二次握手 - 客户端</li>
<li>客户端 — 发送带有 ACK 标志的数据包 —- 三次握手 - 服务端</li>
</ul>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道。说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收都是正常的。</strong></p>
<blockquote>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
</blockquote>
<h3 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="传了-SYN，为啥还要传-ACK"><a href="#传了-SYN，为啥还要传-ACK" class="headerlink" title="传了 SYN，为啥还要传 ACK"></a>传了 SYN，为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道都没问题，但是接收方到发送方的通道还需要 ACK 来进行验证。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204851.png" alt="image-20200907202924109"></p>
<p>断开一个 TCP 连接则需要“<strong>四次挥手</strong>”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>任何一方都可以在数据传送结束后发送连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qzcsu/article/details/72861891">两张动图-彻底明白TCP的三次握手与四次挥手</a></p>
<h2 id="3-TCP-UDP-协议的区别"><a href="#3-TCP-UDP-协议的区别" class="headerlink" title="3. TCP,UDP 协议的区别"></a>3. TCP,UDP 协议的区别</h2><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接性</td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>报文</td>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>效率</td>
<td>传输效率低</td>
<td>传输效率高</td>
</tr>
<tr>
<td>流量控制</td>
<td>滑动窗口</td>
<td>无</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>慢开始、拥塞避免、快重传、快恢复</td>
<td>无</td>
</tr>
<tr>
<td>传输速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>应用场合</td>
<td>对效率要求低，对准确性要求高或要求有连接的场景</td>
<td>对效率要求高，对准确性要求低</td>
</tr>
</tbody></table>
<p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204852.png" alt="image-20200908143417618"></p>
<p><strong>UDP</strong>：在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 <strong>UDP 不提供可靠交付</strong>，但在某些情况下 UDP 确是一种最有效的工作方式（<strong>一般用于即时通信</strong>），比如 QQ语音、QQ视频等。</p>
<p><strong>TCP</strong>：提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束之后要释放连接。 TCP 不提供广播或多播服务。由于 <strong>TCP 要提供可靠的、面向连接的传输服务</strong>（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一操作难免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。<strong>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景</strong>。</p>
<h2 id="4-TCP-协议如何证可靠传输"><a href="#4-TCP-协议如何证可靠传输" class="headerlink" title="4. TCP 协议如何证可靠传输"></a>4. TCP 协议如何证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块；</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层；</li>
<li><strong>校验和</strong>：TCP 将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的变化。如果收到段的校验和有差错，TCP 将会丢弃这个报文段和不确认收到此报文段；</li>
<li>TCP 的接收端会丢弃收到的重复数据；</li>
<li><strong>流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送；</li>
<li><strong>ARQ 协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组；</li>
<li><strong>超时重传</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="5-ARQ-协议"><a href="#5-ARQ-协议" class="headerlink" title="5. ARQ 协议"></a>5. ARQ 协议</h2><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到ACK确认，说明没有发送成功，需要重新发送，知道收到确认再发送下一个分组；</li>
<li>在停止等待协议中，若收到对方重复分组，就丢弃该分组，但同时还要发送确认。</li>
</ul>
<p><strong>优点</strong>：简单</p>
<p><strong>缺点</strong>：信道利用率低，等待时间长</p>
<p>①、<strong>无差错情况：</strong></p>
<p>发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送；</p>
<p>②、<strong>出现差错情况：（超时重传）</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更⻓一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong>。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong>可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p>③、<strong>确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失：</strong>确认消息在传输过程中丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到：</strong>确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h3 id="连续ARQ-协议"><a href="#连续ARQ-协议" class="headerlink" title="连续ARQ 协议"></a>连续ARQ 协议</h3><p>连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点</strong>：信道利用率高，容易实现，即使确认丢失，也不必重传</p>
<p><strong>缺点</strong>：不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了 5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的N 个消息。</p>
<h2 id="6-滑动窗口和流量控制"><a href="#6-滑动窗口和流量控制" class="headerlink" title="6. 滑动窗口和流量控制"></a>6. 滑动窗口和流量控制</h2><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方速率，保证接收方来得及接收</strong>。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<h2 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. 拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法：<strong>慢开始、拥塞避免、快重传和快恢复</strong>。</p>
<blockquote>
<ul>
<li><strong>慢开始</strong>：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免</strong>：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复</strong>：在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
</blockquote>
<h2 id="8-在浏览器中输入-url-地址-gt-gt-显示主页的过程（面试高频）"><a href="#8-在浏览器中输入-url-地址-gt-gt-显示主页的过程（面试高频）" class="headerlink" title="8. 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程（面试高频）"></a>8. 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程（面试高频）</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908204853.png" alt="image-20200908195147847"></p>
<p>总体分为以下几个过程：</p>
<ol>
<li>DNS 解析；</li>
<li>TCP 连接；</li>
<li>发送 HTTP 请求；</li>
<li>服务器处理请求并返回 HTTP 报文；</li>
<li>浏览器解析并渲染页面；</li>
<li>连接结束。</li>
</ol>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006879700">前端经典面试题:从输入URL到页面加载发生了什么?</a></p>
<h2 id="9-状态码"><a href="#9-状态码" class="headerlink" title="9. 状态码"></a>9. 状态码</h2><table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2 XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3 XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4 XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5 XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="10-各种协议与HTTP协议之间的关系"><a href="#10-各种协议与HTTP协议之间的关系" class="headerlink" title="10. 各种协议与HTTP协议之间的关系"></a>10. 各种协议与HTTP协议之间的关系</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.silentcow.cn/20200908200521.png" alt="670882-20190218113529176-278963322"></p>
<h2 id="11-HTTP-长连接，短连接"><a href="#11-HTTP-长连接，短连接" class="headerlink" title="11. HTTP 长连接，短连接"></a>11. HTTP 长连接，短连接</h2><p>在 <strong>HTTP/1.0 中默认使用短连接</strong>。也就是说，客户端和服务器每进行一次HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>从 <strong>HTTP/1.1 开始默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用⻓连接的情况下，当一个网⻚打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客户端和服务端都支持⻓连接。</p>
<p><strong>HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。</strong></p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP协议的⻓连接和短连接到底是什么？</a></p>
<h2 id="12-HTTP是不保存状态的协议-如何保存用户状态"><a href="#12-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="12. HTTP是不保存状态的协议,如何保存用户状态?"></a>12. HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，<strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是<strong>通过在Cookie 中附加一个 Session ID 来方式来跟踪</strong>。</p>
<blockquote>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
</blockquote>
<h2 id="13-Cookie的作用是什么？和Session有什么区别？"><a href="#13-Cookie的作用是什么？和Session有什么区别？" class="headerlink" title="13. Cookie的作用是什么？和Session有什么区别？"></a>13. Cookie的作用是什么？和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong>比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候⻚面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token重写)；③登录一次网站后访问网站其他⻚面不需要重新登录。</p>
<p><strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="14-URI-和-URL-的区别是什么？"><a href="#14-URI-和-URL-的区别是什么？" class="headerlink" title="14. URI 和 URL 的区别是什么？"></a>14. URI 和 URL 的区别是什么？</h2><ul>
<li><strong>URI</strong>（Uniform Resource Identifie）：<strong>是统一资源标识符，可以唯一标识一个资源</strong>；</li>
<li><strong>URL</strong>（(Uniform Resource Location）：<strong>是统一资源定位符，可以提供该资源的路径</strong>。它<strong>是一种具体的URI</strong>，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<blockquote>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL是一种更具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
</blockquote>
<h2 id="15-HTTP-和-HTTPS-的区别？"><a href="#15-HTTP-和-HTTPS-的区别？" class="headerlink" title="15. HTTP 和 HTTPS 的区别？"></a>15. HTTP 和 HTTPS 的区别？</h2><ol>
<li><strong>端口</strong>：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗</strong>： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，<strong>HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源</strong>。<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">silentcow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://silentcow.cn/2020/09/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://silentcow.cn/2020/09/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://silentcow.cn" target="_blank">silentcow</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">Java面试总结</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a></div><div class="post_share"><div class="social-share" data-image="https://img.silentcow.cn/20200908205424.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/09/%E5%89%91%E6%8C%87Offer%2005-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"><img class="prev-cover" data-lazy-src="https://img.silentcow.cn/20200830005616.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【剑指Offer】替换空格</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next-cover" data-lazy-src="https://img.silentcow.cn/20200906214127.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Java面试总结】多线程</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/31/【Java面试总结】完整版（更新中）/" title="【Java面试总结】完整归类版"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200831104016.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-31</div><div class="relatedPosts_title">【Java面试总结】完整归类版</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/06/【Java面试】多线程/" title="【Java面试总结】多线程"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200906214127.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-06</div><div class="relatedPosts_title">【Java面试总结】多线程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/02/【Java面试】Java集合/" title="【Java面试总结】Java集合"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200903001313.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="relatedPosts_title">【Java面试总结】Java集合</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/30/【Java面试】Java基础(下篇)/" title="【Java面试总结】Java基础(下篇)"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200829161806.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-30</div><div class="relatedPosts_title">【Java面试总结】Java基础(下篇)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/29/【Java面试总结】Java基础(上篇)/" title="【Java面试总结】Java基础(上篇)"><img class="relatedPosts_cover" data-lazy-src="https://img.silentcow.cn/20200829160851.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-29</div><div class="relatedPosts_title">【Java面试总结】Java基础(上篇)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://img.silentcow.cn/20200908205424.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By silentcow</div><div class="footer_custom_text">❤把生命浪费在美好的事物上❤</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>陕ICP备20007232</span></a></div><a src="https://www.upyun.com/static/img/%E6%A0%B7%E5%BC%8F%E5%9B%BE.7cf927c.png" style="width: 248px" target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral">本站由又拍云提供CDN加速服务</a></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '8o941pQWci2RW0uP8DjOWl2P-gzGzoHsz',
      appKey: 'WQPP2IUvnbXswLjEgsgSJy0T',
      placeholder: '记得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'monsterid',
      meta: '昵称(必填),邮箱(必填),主页'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('昵称(必填),邮箱(必填)') { valine.config.requiredFields= '昵称(必填),邮箱(必填)'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>